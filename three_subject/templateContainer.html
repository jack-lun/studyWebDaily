<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ThreeJs学习</title>
</head>
<body>

<script type="importmap">
    {
        "imports": {
            "three": "./three.js/build/three.module.js",
            "three/addons/": "./three.js/examples/jsm/"
        }
    }
</script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
    import mesh from './src/meshObj.js';

    // 实例化一个GUI对象
    const gui = new GUI();
    gui.domElement.style.right = '100px';
    gui.domElement.style.width = '300px';


    const scene = new THREE.Scene();
    scene.add(mesh);

    console.log('mesh', mesh);
    gui.add(mesh.position, 'x', 0, 500);
    gui.add(mesh.position, 'y', 0, 500);
    gui.add(mesh.position, 'z', 0, 500);

    // 辅助观察坐标系
    const axesHelper = new THREE.AxesHelper(200);
    scene.add(axesHelper);

    //设置光源
    const directionLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionLight.position.set(400, 200, 300);
    scene.add(directionLight);
    const ambient = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambient);

    // 创建透视投影相机
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(290, 223, 185);
    camera.lookAt(0, 0, 0);

    // 创建渲染器
    const renderer = new THREE.WebGLRenderer(
        {
            antialias: true
        }
    );
    // 抗锯齿还可以renserer.antialias = true;
    // 如果遇到你的canvas画布比较模糊，可以设置屏幕像素比，（如果window.devicePixelRatio为1的话，设不设置区别不大，但一般都需要设置）
    renderer.setPixelRatio(window.devicePixelRatio);
    // 设置背景颜色
    renderer.setClearColor(0x444444);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 控制器
    const controls = new OrbitControls(camera, renderer.domElement);

    function animation() {
        renderer.render(scene, camera);
        requestAnimationFrame(animation);
    }

    animation();

    // 画布跟随窗口变化
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

</script>
</body>
</html>